\documentclass[12pt]{article}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fontspec}
%% \setmainfont[Ligatures=TeX]{cmunrm.otf}
%% \setmonofont[Ligatures=TeX]{Inconsolata LGC}
\usepackage{fancyvrb,newverbs,xcolor}
\definecolor{cverbbg}{gray}{0.93}
\usepackage{minted}
\title{IndProp: comments upon nostutter excersizes}
\author{Ivanov Dmitriy
\and
Bubbler
}
\newcommand{\codeBlock}[1]{\colorbox{cverbbg}{\parbox{0.85\textwidth}{#1}}}
\begin{document}
\maketitle
\tableofcontents

\vspace{3em}
IndProp contains nostutter exersize with number of unit tests provided by the authors of the book that check the correctness of inductive nostutter type. Unfortunately, no explanations are provided of how the proofs work. Here are the explanations and alternative solutions of these excersizes.

\begin{minted}{coq}
Inductive nostutter {X:Type} : list X -> Prop :=
| ns_nil : nostutter []
| ns_one : forall (x : X), nostutter [x]
| ns_cons: forall (x : X) (h : X) (t : list X),
                  nostutter (h::t) -> x <> h -> nostutter (x::h::t).
\end{minted}

\section{Example test\_nostutter\_1}

\begin{minted}{coq}
Example test_nostutter_1: nostutter [3;1;4;1;5;6].
Proof.
  repeat constructor; apply eqb_neq; auto.
Qed.
\end{minted}

To understand what's going on here we need to know

1. {\tt repeat} tactical (tactical is a tactic applied to another tactic).

From coq reference manual we get the following:

\begin{minted}{coq}
  repeat expr
\end{minted}

\begin{quote}
expr is evaluated to v. If v denotes a tactic, this tactic is applied to each focused goal independently. If
the application succeeds, the tactic is applied recursively to all the generated subgoals until it eventually
fails. The recursion stops in a subgoal when the tactic has failed to make progress. The tactic repeat
expr itself never fails.
\end{quote}

2. ; (semicolon) tactical

Semicolon allows us to join expressions into a sequence:

\begin{minted}{coq}
  expr1 ; expr2
\end{minted}

The expression expr1 is evaluated to $v_1$, which must be a tactic value. The tactic $v_1$ is applied to the
current goal, possibly producing more goals. Then expr2 is evaluated to produce $v_2$, which must be a
tactic value. The tactic v2 is applied to all the goals produced by the prior application. Sequence is
associative.

Based upon this knowledge we can deduce that

\begin{minted}{coq}
  constructor; apply eqb_neq; auto
\end{minted}

will first apply constructor tactic, then to all the goals generated by it it will apply eqb\_neq, and then to all the goals left it will apply auto.

Now let's look at {\tt constructor} tactic

\begin{minted}{coq}
  constructor num
\end{minted}

This tactic applies to a goal such that its conclusion is an inductive type (say I). The argument num
must be less or equal to the numbers of constructor(s) of I. Let $c_i$ be the i-th constructor of I, then
constructor i is equivalent to intros; apply $c_i$.

\begin{minted}{coq}
Variant: constructor
\end{minted}

This tries constructor 1 then constructor 2, ..., then constructor n where n is the number
of constructors of the head of the goal.

So, constructor will try all the available constructors upon the goal until one matches. Let's take a look how it works: we have a goal with no premises:

\begin{minted}{coq}
  nostutter [3;1;4;1;5;6]
\end{minted}

coq will see that

\begin{minted}{coq}
| ns_cons: forall (x : X) (h : X) (t : list X),
                  nostutter (h::t) -> x <> h -> nostutter (x::h::t).
\end{minted}

constructor matches the goal with parameters:

\begin{minted}{coq}
x = 3
h = 1
t = [4;1;5;6]
\end{minted}

And we have 2 hypotheses for this constructor:


\begin{itemize}
\item \mintinline{coq}{nostutter (h::t) => nostutter (1;4;1;5;6)}
\item \mintinline{coq}{x <> h => 3 <> 1}
\end{itemize}

Original goal will be replaced by 2 subgoals, so if we run {\tt constructor} now, we'll see the following:

\begin{minted}{coq}
2 subgoals (ID 441)

  ============================
  nostutter [1; 4; 1; 5; 6]

subgoal 2 (ID 442) is:
 3 <> 1
\end{minted}

Now let's look at the next command:

\begin{minted}{coq}
apply eqb_neq

Check eqb_neq.
\end{minted}

\noindent
\begin{minipage}[t]{0.8\textwidth}
\codeBlock{{\tt
eqb\_neq\\
: forall x y : nat, (x =? y) = false <-> x <> y
}}
\end{minipage}

\vspace{2em}
``{\tt =?}'' is a notation for {\tt eqb} function that takes 2 nats and returns a bool, that indicates their equality:

\begin{minted}{coq}
Check eqb.
\end{minted}

\noindent
\begin{minipage}[t]{.45\textwidth}
\codeBlock{{\tt
eqb\\
     : nat -> nat -> bool
}}
\end{minipage}

\vspace{1em}
If we manually apply it after constructor, it will fail because it won't match the first subgoal. If we want it not to fail, we need to wrap it into {\tt try} tactical:

\begin{minted}{coq}
constructor; try (apply eqb_neq).
\end{minted}

\noindent
\begin{minipage}[t]{.45\textwidth}
\codeBlock{{\tt
2 subgoals (ID 441)\\
\\
============================\\
  nostutter [1; 4; 1; 5; 6]\\
\\
subgoal 2 (ID 452) is:\\
  (3 =? 1) = false
}}
\end{minipage}

\vspace{1em}
The prop was transformed to an equality of 2 booleans. On of them is a result returned by eqb function. {\tt auto} will solve the second subgoal:

\begin{minted}{coq}
  (3 =? 1) = false => false = false => True
\end{minted}

Now the second goal is solved, and we have the inital problem reduced by 1 step:

\begin{minted}{coq}
constructor; try (apply eqb_neq) ; auto.

(* Response *)
1 subgoal (ID 441)

============================
nostutter [1; 4; 1; 5; 6]
\end{minted}

repeat doesn't fail, so the original solution doen't need to use {\tt try}.

We could write the proof without {\tt repeat} like this:

\begin{minted}{coq}
Example test_nostutter_1: nostutter [3;1;4;1;5;6].
Proof.
  constructor ; try (apply eqb_neq) ; auto.
  constructor ; try (apply eqb_neq) ; auto.
  constructor ; try (apply eqb_neq) ; auto.
  constructor ; try (apply eqb_neq) ; auto.
  constructor ; try (apply eqb_neq) ; auto.
  constructor ; try (apply eqb_neq) ; auto.
Qed.
\end{minted}

If we wanted to write it without tacticals, we need to find a way to apply {\tt eqb\_neq} to the second goal only. To find how to do it let's look
at ``Navigation in the proof tree'' chapter of reference manual:

\begin{minted}{coq}
num: {
This focuses on the num-th subgoal to prove.

[ident]: {
This focuses on the named goal ident.
\end{minted}

So, we'll get this:

\begin{minted}{coq}
Proof.
  constructor.
  2: {apply eqb_neq. auto. }
\end{minted}

\noindent
\begin{minipage}[t]{.45\textwidth}
\codeBlock{{\tt
1 subgoal (ID 441)

============================\\
nostutter [1; 4; 1; 5; 6]
}}
\end{minipage}

\vspace{2em}
Mention the space after {\tt auto.}, it is necessary. Without it coq hangs. Actually, if we replace auto with {\tt simpl. reflexivity.} or {\tt trivial.} it will also work. So, we have 3 options to use here:

\begin{itemize}
\item {\tt simpl. reflexivity.}
\item {\tt trivial.}
\item {\tt auto.}
\end{itemize}

So manual solution here without tacticals will look like this:

\begin{minted}{coq}
Proof.
  (* [3;1;4;1;5;6] *)
  constructor.
  2: {apply eqb_neq. trivial. }
  (* [1;4;1;5;6] *)
  constructor.
  2: {apply eqb_neq. simpl. reflexivity. }
  (* [4;1;5;6] *)
  constructor.
  2: {apply eqb_neq. auto. }
  (* [1;5;6] *)
  constructor.
  2: {apply eqb_neq. auto. }
  (* [5;6] *)
  constructor.
  2: {apply eqb_neq. auto. }
  (* [6], ns_one applied*)
  constructor.
Qed.
\end{minted}

Alternatively we can add a parameter to constructor tactic to make it work faster:

\begin{minted}{coq}
Proof.
  (* [3;1;4;1;5;6] *)
  constructor 3.
  2: {apply eqb_neq. trivial. }
  (* [1;4;1;5;6] *)
  constructor 3.
  2: {apply eqb_neq. simpl. reflexivity. }
  (* [4;1;5;6] *)
  constructor 3.
  2: {apply eqb_neq. auto. }
  (* [1;5;6] *)
  constructor 3.
  2: {apply eqb_neq. auto. }
  (* [5;6] *)
  constructor 3.
  2: {apply eqb_neq. auto. }
  (* [6], ns_one applied*)
  constructor 2.
Qed.
\end{minted}

Repeat ignores the failure upon applying of {\tt eqb\_neq} to the first subgoal and we get the following neat one-liner:

\begin{minted}{coq}
repeat constructor; apply eqb_neq; auto.
\end{minted}

\subsection{Solving the problem using {\tt do} tactical}

We can use another tactical ``{\tt do}'' to solve the problem in a different manner. {\tt do} repeats a tactic num times:

\begin{minted}{coq}
do num expr
\end{minted}

\begin{quote}
expr is evaluated to v which must be a tactic value. This tactic value v is applied num times. Supposing num > 1, after the first application of v, v is applied, at least once, to the generated subgoals and so on. It fails if the application of v fails before the num applications have been completed.
\end{quote}

As {\tt do} can fail, we'll need to explicitly apply {\tt eqb\_ned} to the second subgoal every time. First of all, we can't use ``2: {}'' after the chain operator ;. So this won't work:

\begin{minted}{coq}
do 5 constructor 3; 2: {apply eqb_neq. auto. }
\end{minted}

Instead we can use sequence with local application:

\begin{minted}{coq}
tac; [tac1 | tac2].
\end{minted}

Since we want to do something on just the second branch, we can omit tac1. Finally, {\tt do n tac; tac} works like {\tt (do n tac); tac}. We can wrap a tactic expression with parentheses, e.g. do n (tac; tac) to change the behaviour. Also, we can't use periods inside a tactical. A period marks the end of a statement, but the whole do expression is a single statement. We should always use sequence operator ; to chain several tactics. So this one will work:

\begin{minted}{coq}
do 5 (constructor 3; [ | apply eqb_neq; auto ]).
constructor.
\end{minted}

\subsection{Simplification}

We can simplify the code in several ways.

auto can be given extra theorems to automate with. Any goal solvable with {\tt apply eqb\_neq; auto} is also solvable with {\tt auto using eqb\_neq}.

\begin{minted}{coq}
do 5 (constructor 3; [ | auto using eqb_neq ]).
\end{minted}

The auto tactic never fails, so it can be safely used on both branches.

\begin{minted}{coq}
do 5 (constructor 3; auto using eqb_neq).
\end{minted}

repeat repeats until something fails or there are no more subgoals. The following will repeat until the 3rd constructor is no longer applicable.

\begin{minted}{coq}
repeat (constructor 3; auto using eqb_neq).
\end{minted}

We can let Coq choose which constructor to apply. This can finish the proof.

\begin{minted}{coq}
repeat (constructor; auto using eqb_neq).
\end{minted}

We can also make constructors of nostutter automated by auto using Hint Constructors command. Now we can auto the whole thing. If we place the hint command after the definition of nostutter, we can auto it everywhere.

\begin{minted}{coq}
Hint Constructors nostutter.
(* Default search depth is 5 by default. We increased it to 6. *)
auto 6 using eqb_neq.
\end{minted}

Actually, the theorem {\tt eqb\_neq} is already registered for auto. So we can just:

\begin{minted}{coq}
auto 6.
\end{minted}

\section{test\_nostutter\_4}

\begin{minted}{coq}
Example test_nostutter_4: not (nostutter [3;1;1;4]).
Proof.
  intro.
  repeat match goal with
    h: nostutter _ |- _ => inversion h; clear h; subst
         end.
  contradiction.
Qed.
\end{minted}

Let's first prove it the hard way:

\begin{minted}{coq}
Example test_nostutter_manual: not (nostutter [3;1;1;4]).
Proof.
  intro.
  inversion_clear H.
  inversion_clear H0.
  unfold not in H2.
  specialize (H2 eq_refl).
  apply H2.
Qed.
\end{minted}

Now let's look how the theorem is proven step by step.

\vspace{1em}
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
intro.
\end{minted}

\codeBlock{\tt{
H : nostutter [3; 1; 1; 4]\\
============================\\
False
}}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
inversion_clear H.
(* H was destructed into
   H0 and H1 *)
\end{minted}

\codeBlock{\tt{
\textit{H0 : nostutter [1; 1; 4]}\\
\textit{H1 : 3 <> 1}\\
============================\\
False
}}
\end{minipage}

\vspace{2em}
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
inversion_clear H0.
(* H was destructed into
   H0 and H1 *)
\end{minted}

\codeBlock{{\tt
H1 : 3 <> 1\\
\textit{H : nostutter [1; 4]}\\
\textit{H2 : 1 <> 1}\\
============================\\
False
}}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
unfold not in H2.
\end{minted}

\codeBlock{{\tt
      H1 : 3 <> 1\\
      H : nostutter [1; 4]\\
      \textit{H2 : 1 = 1 -> False}\\
      ============================\\
      False
}}
\end{minipage}

\vspace{2em}
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
specialize (H2 eq_refl).
\end{minted}

\codeBlock{\tt{
H1 : 3 <> 1\\
H : nostutter [1; 4]\\
\textit{H2 : False}\\
============================\\
False
}}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
apply H2.
\end{minted}

\codeBlock{\tt{
No more subgoals.
}}
\end{minipage}

\subsection{specialize tactic}
Let's look at {\tt specialize} tactic. {\tt specialize}, in its simplest form, replaces a given hypothesis with that hypothesis applied to some other term.

\begin{minted}{coq}
Example specialize {A B: Type} (H: A -> B) (a: A): B.
Proof.
  specialize (H a).
  exact H.
Qed.
\end{minted}

We initially have the hypothesis {\tt H: A -> B}. When we call {\tt specialize (H a)}, we apply H to a (apply as in function application). This gives us something of type B. {\tt specialize} then gets rid of the old H for us and replaces it with the result of the application. It gives the new hypothesis the same name: H.

To understand what's going on in {\tt specialize (H2 eq\_refl).} here, let's take a look at the definition of {\tt eq} Prop:

\begin{minted}{coq}
Inductive eq (A:Type) (x:A) : A -> Prop :=
    eq_refl : x = x :>A

where "x = y :> A" := (@eq A x y) : type_scope.
\end{minted}

In our case, we have {\tt H2: 1 = 1 -> False}, which is a function from the type {\tt 1 = 1} to the type {\tt False}. That means that H2 applied to {\tt eq\_refl} is of type False, i.e. {\tt H2 eq\_refl: False}. When we use the tactic {\tt specialize (H2 eq\_refl).}, the old H2 is cleared and replaced by a new term {\tt (H2 eq\_refl)} whose type is False.

\subsection{match goal with tactic}

Returning to our original problem. Here we see a new tactic: {\tt match goal with}:

\begin{minted}{coq}
match goal with hyp+ |- cpattern => expr+| | _ => eval_expr end
\end{minted}

For the simple case: if there is a hypothesis matching {\tt cpattern} and the goal matches {\tt expr} then {\tt eval\_expr} is evaluated.

So this code {\tt h: nostutter \_ |- \_ => inversion h; clear h; subst} means: if there is a hypothesis {\tt h} that has a type {\tt nostutter \_} and the goal matches anything, then execute the code: {\tt inversion h; clear h; subst}. Let's look at subst tactic:

\begin{minted}{coq}
subst ident
\end{minted}

\begin{quote}
This tactic applies to a goal that has ident in its context and (at least) one hypothesis, say H, of type ident = t or t = ident with ident not occurring in t. Then it replaces ident by t everywhere in the goal (in the hypotheses and in the conclusion) and clears ident and H from the context.
\end{quote}

\begin{minted}{coq}
subst
\end{minted}

\begin{quote}
This applies subst repeatedly from top to bottom to all identifiers of the context for which an equality of the form ident = t or t = ident or ident := t exists, with ident not occurring in t.
\end{quote}

Here is a simple example of using {\tt subst}:

\begin{minted}{coq}
Lemma equality_commutes:
  forall (a: bool) (b: bool), a = b -> b = a.
Proof.
  intros.
  subst a.
  reflexivity.
Qed.
\end{minted}

\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
intros.
\end{minted}

\codeBlock{{\tt
a, b : bool\\
H : a = b\\
============================\\
b = a
}}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
subst a.
\end{minted}

\codeBlock{{\tt
b : bool\\
============================\\
b = b
}}
\end{minipage}

So, if we run through these 3 commands, we get this:

\begin{minted}{coq}
Example test_nostutter_4_3commands: not (nostutter [3;1;1;4]).
Proof.
  intro.
  inversion H.
  clear H.
  subst.
Abort.
\end{minted}

\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
intros.
\end{minted}

\codeBlock{{\tt
H : nostutter [3; 1; 1; 4]\\
============================\\
False
}}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
inversion H.
\end{minted}

\codeBlock{{\tt
H : nostutter [3; 1; 1; 4]\\
x, h : nat\\
t : list nat\\
H2 : nostutter [1; 1; 4]\\
H4 : 3 <> 1\\
H0 : x = 3\\
H1 : h = 1\\
H3 : t = [1; 4]\\
============================\\
False
}}
\end{minipage}

%second row
\vspace{2em}
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
clear H.
\end{minted}

\codeBlock{{\tt
x, h : nat\\
t : list nat\\
H2 : nostutter [1; 1; 4]\\
H4 : 3 <> 1\\
H0 : x = 3\\
H1 : h = 1\\
H3 : t = [1; 4]\\
============================\\
False
}}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{minted}{coq}
subst.
(* all the hypotheses with variables
were cleared as there is nothing
to substitute in the goal. *)
\end{minted}

\codeBlock{{\tt
H2 : nostutter [1; 1; 4]\\
H4 : 3 <> 1\\
============================\\
False
}}
\end{minipage}

\vspace{2em}
So, these 3 commands \mintinline{coq}{inversion H. clear H. subst.} are equivalent to {\tt inversion\_clear.}

The last tactic used is contradiction:

\begin{minted}{coq}
contradiction
\end{minted}

\begin{quote}
This tactic applies to any goal. The contradiction tactic attempts to find in the current context (after all intros) a hypothesis that is equivalent to an empty inductive type (e.g. False), to the negation of a singleton inductive type (e.g. True or x=x), or two contradictory hypotheses.
\end{quote}

Here is a list of items we've learnt.

\noindent
Tacticals:

\begin{enumerate}
\item repeat
\item ;
\item try
\item do
\end{enumerate}

Tactics:
\begin{enumerate}
\item constructor
\item auto
\item trivial
\item This focusing on the num-th subgoal to prove: {\tt num: \{}
\item local application for sequence: {\tt tac; [tac1 | tac2].}
\item {\tt Hint Constructors} command for {\tt auto}
\item specialize
\item match goal with
\item subst ident
\item subst
\item contradiction
\end{enumerate}
\end{document}
